(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["automacao-core-playwright"] = {}));
})(this, (function (exports) { 'use strict';

  const moment$1 = require('moment');
  const {
    expect
  } = require('@playwright/test');
  const {
    addDays: addDays$1,
    isWeekend,
    format: format$1
  } = require('date-fns');
  const dotenv$1 = require('dotenv');
  dotenv$1.config();
  let contadorMenu = 0;
  const FRAME = 'iframe[name="ci"]';
  class DataUtils {
    constructor(page) {
      this.page = page;
    }
    /**
    * Realiza o processo de login na página.
    * @param {Object} usuario - As informações de usuário para autenticação.
     * @example
     * const usuario = {
     *   email: 'seu_usuario@senior.com', {string}
     *   senha: 'sua_senha', {string}
     * };
    */
    async login(usuario) {
      await this.page.goto('/');
      const password = this.page.getByPlaceholder('Senha');
      const userName = this.page.getByPlaceholder('usuario@dominio.com.br');
      await userName.fill(usuario.email);
      await this.page.getByRole('button', {
        name: 'Próximo'
      }).click();
      await password.fill(usuario.senha);
      await this.page.locator('[id="loginbtn"]').click();
      console.log(`Usuário ${usuario.email} logado com sucesso`);
    }
    /**
    * Navega para a página da plataforma.
    * @param {string} produto - Produto a ser acessado.
    * @param {string|null} modulo - Módulo a ser acessado.
    * @param {string|null} area - Área a ser acessada.
    * @param {string|null} processo - Processo a ser acessado.
    * @param {string|null} subProcesso - Subprocesso a ser acessado.
    * @param {string|null} subProcesso2 - Segundo subprocesso a ser acessado.
    * @param {string|null} subProcesso3 - Terceiro subprocesso a ser acessado.
    */
    async navegarParaPagina(produto) {
      let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      let area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      let processo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      let subProcesso = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      let subProcesso2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      let subProcesso3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
      const produtoXpath = `xpath=//div[contains(text(), "${produto}")]/ancestor::span[1]`;
      await this.page.waitForSelector(produtoXpath, {
        timeout: 60000
      });
      await this.page.locator(produtoXpath).click({
        force: true
      });
      const menuCount = await this.page.locator('#apps-menu-sublabel:has-text("Menu")').count();
      menuCount > 0 && (contadorMenu = 0);
      if (contadorMenu != 0) {
        do {
          const sublabelXpath = '[id="apps-menu-sublabel"]';
          await this.page.waitForSelector(sublabelXpath, {
            timeout: 60000
          });
          await this.page.locator(sublabelXpath).click({
            force: true
          });
          contadorMenu--;
        } while (contadorMenu > 1);
        contadorMenu = 0;
      }
      await this.navegarSeExistir(modulo);
      await this.navegarSeExistir(area);
      await this.navegarSeExistir(processo);
      await this.navegarSeExistir(subProcesso);
      await this.navegarSeExistir(subProcesso2);
      await this.navegarSeExistir(subProcesso3);
    }
    /**
     * Navega para um item do menu se ele existir.
     *
     * @param {string} itemMenu - O item para o qual navegar.
     * @returns {Promise} Uma promessa que se resolve quando a navegação é concluída.
     */
    async navegarSeExistir(itemMenu) {
      if (itemMenu) {
        const elementoMenuFiltrandoPeloFinalDaString = `a[aria-label$="${itemMenu}"]`;
        await this.page.locator(elementoMenuFiltrandoPeloFinalDaString).scrollIntoViewIfNeeded();
        await this.page.waitForSelector(elementoMenuFiltrandoPeloFinalDaString, {
          timeout: 60000
        });
        await this.page.locator(elementoMenuFiltrandoPeloFinalDaString).click({
          force: true
        });
        contadorMenu++;
      }
    }
    /**
     * Encontra um colaborador em uma tabela dentro de um iframe que
     * tem o seguinte locator: table.table tbody.
     *
     * @param {string} seletorTabela - Xpath ou locator referente a tabela desejada
     * @param {string} valorBusca - O valor a ser encontrado na tabela
     * @returns {Promise<ElementHandle>} Uma promessa que se resolve com a linha da tabela que contém o colaborador.
     * @throws {Error} Lança um erro se não conseguir localizar o colaborador na tabela.
     */
    async encontrarValorNaTabela(seletorTabela, valorBusca) {
      const frameElement = await this.page.$(FRAME);
      const frame = await frameElement.contentFrame();
      await frame.waitForSelector(seletorTabela, {
        timeout: 60000
      });
      const linhas = await frame.locator(seletorTabela).elementHandles();
      for (let i = 0; i < linhas.length; i++) {
        // Obtenha o manipulador de elementos para a linha atual dentro do loop
        const linha = linhas[i];
        const celulas = await linha.$$('td');
        for (let j = 0; j < celulas.length; j++) {
          const valorCelula = await celulas[j].innerText();
          if (valorCelula === valorBusca) {
            return linha;
          }
        }
      }
      return null;
    }
    /**
     *  Função que verifica se um elemento está desabilitado na tela.
     * @param {string} componente informar qual é o elemento que deve ser validado na tela, locator
     * @param {string} desabilitado qual o valor esperado para ser comparado (true, false)
     */
    async verificaElementoDesabilitado(componente, desabilitado) {
      const frame = await this.page.frame({
        name: 'ci'
      });
      const isDisabled = await frame.$void(componente, el => el.hasAttribute('disabled'));
      //const isDisabled = await frame.$void(componente, el => el.disabled);
      if (desabilitado) {
        expect(isDisabled).toBe(true);
        console.log('Botão ou campo desabilitado');
      } else {
        expect(isDisabled).toBe(false);
        console.log('Botão ou campo esta habilitado');
      }
    }
    async limparCampo(locator) {
      const frame = await this.page.frame({
        name: 'ci'
      });
      await frame.locator(locator).click();
      await frame.locator(locator).press('Control+A');
      await frame.locator(locator).press('Backspace');
    }
    /**
    * Converte uma data no formato brasileiro para o formato americano (YYYY-MM-DD).
    * @param {string} data - Data no formato brasileiro (DD/MM/AAAA).
    * @returns {string} - Data no formato americano (YYYY-MM-DD).
    */
    formataDataAmericano(data) {
      return moment$1(data, 'DD/MM/YYYY').format('YYYY-MM-DD');
    }
    /**
    * Função que valida se a data informada é um feriado nacional, caso seja, retorna o dia seguinte ao feriado.
    * @param {string} dataInicioFerias - Data para validação (formato brasileiro de data - 22/04/2021)
    * @returns {string} - Data no formato "dia/mês/ano"
    */
    async validarFeriados(dataInicioFerias) {
      const dataValidarFeriadosEng = await this.formataDataAmericano(dataInicioFerias);
      const data = new Date(`"${dataValidarFeriadosEng}"`);
      const feriados = ['01/01', '21/04', '01/05', '02/09', '07/09', '12/10', '02/11', '15/11', '25/12'];
      let inicioFerias;
      let continuar = true;

      // Verifica a data de início das férias e os dois dias anteriores
      while (continuar) {
        continuar = false;
        for (let i = 0; i < 3; i++) {
          const novoDia = data.getDate() + i;
          const novoMes = data.getMonth() + 1;
          inicioFerias = this.configurarDiaMes(novoDia, novoMes);

          // Se a data for um feriado, ajusta a data de início das férias para o dia seguinte ao feriado
          if (feriados.includes(inicioFerias)) {
            data.setDate(data.getDate() + 3);
            continuar = true;
            break;
          }
        }
      }
      inicioFerias = this.configurarDiaMes(data.getDate(), data.getMonth() + 1);
      return `${inicioFerias}/${data.getFullYear()}`;
    }
    /** Função que valida se a data informada: é uma Sexta, Sábado ou Domingo, caso o retorno seja positivo,
    *  a data é forçada para a próxima Segunda.
    * @param {data} dataInicioFerias data para validação (em formato brasileiro de data - 22/04/2021)
    * REGRA DE NEGÓCIO G5: Não é permitido iniciar as férias no período de dois dias que antecedem um DSR.
        [0] - Domingo
        [1] - Segunda
        [2] - Terça
        [3] - Quarta
        [4] - Quinta
        [5] - Sexta
        [6] - Sábado
    * @returns {string} - Data ajustada, se necessário, para a próxima Segunda.
    **/
    async validarDiaUtilFerias(dataInicioFerias) {
      // Valida se a data informada é um feriado
      let dataValidarFeriados = await this.validarFeriados(dataInicioFerias);
      // Valida se a data é véspera de um feriado
      dataValidarFeriados = await this.page.feriasPage.validarVesperaFeriados(dataValidarFeriados);
      // Formata a data informada no padão americano
      const dataValidarFeriadosEng = await this.formataDataAmericano(dataValidarFeriados);
      let data = new Date(dataValidarFeriadosEng);
      // Se a data for uma sexta-feira, sábado ou domingo, ajusta a data para a próxima segunda-feira
      if (isWeekend(data) || data.getDay() === 5) {
        while (isWeekend(data) || data.getDay() !== 1) {
          data = addDays$1(data, 1);
        }
      }
      return format$1(data, 'dd/MM/yyyy');
    }
    /**
    * Configura o dia e o mês com zero à esquerda se o valor for menor que 10.
    * @param {number} dia - O dia a ser configurado.
    * @param {number} mes - O mês a ser configurado.
    * @param {boolean} [formatAmericano=false] - Se true, retorna no formato americano (mes/dia); caso contrário, retorna no formato brasileiro (dia/mes).
    * @returns {string} - Dia e mês formatados.
    */
    configurarDiaMes(dia, mes) {
      let formatAmericano = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const data = new Date(0, mes - 1, dia); // Ano 0 é usado aqui porque só estamos interessados no mês e no dia
      if (formatAmericano) {
        return format$1(data, 'MM/dd');
      } else {
        return format$1(data, 'dd/MM');
      }
    }
    /**
     * Valida se não há mensagens de erro na tela.
     *
     * Esta função verifica se determinadas mensagens de erro comuns não estão visíveis no frame especificado.
     *
     * @async
     * @function validaSemMsgErroEmTela
     * @returns {Promise<void>} Uma promessa que é resolvida quando todas as verificações são concluídas.
     */
    async validaSemMsgErroEmTela() {
      const frame = await this.page.frameLocator(FRAME);
      const errorMessages = ['Ocorreu um erro inesperado no servidor:', 'Erro', 'Oops', 'Erro na busca das informações.', 'expection'];
      await Promise.all(errorMessages.map(async errorMessage => {
        await expect(frame.getByText(errorMessage, {
          exact: false
        })).toBeHidden();
      }));
    }
    /**
     * Valida a tradução de mensagens comuns na tela.
     *
     * Esta função verifica se as mensagens de tradução e os botões comuns estão ocultos no frame especificado.
     *
     * @async
     * @function validaTraducaoComunsEmTela
     * @returns {Promise<void>} Uma promessa que é resolvida quando todas as verificações são concluídas.
     */
    async validaTraducaoComunsEmTela() {
      const frame = this.page.frameLocator(FRAME);
      const translateMessages = ['erpx_', 'erp_'];
      const buttonsElements = ['add', 'edit', 'cancel', 'delete', 'save'];
      await Promise.all([...translateMessages.map(async translateMessage => {
        await expect(frame.getByRole('body')).toBeHidden(translateMessage);
      }), ...buttonsElements.map(async buttonsMessage => {
        await expect(frame.getByRole('button', {
          name: buttonsMessage
        })).toBeHidden();
      })]);
    }
  }

  const {
    ptBR
  } = require('date-fns/locale');
  const moment = require('moment');
  const {
    addDays,
    addMonths,
    addYears,
    parse,
    format,
    addHours,
    addMinutes,
    addSeconds
  } = require('date-fns');
  const dotenv = require('dotenv');
  dotenv.config();
  class FormatDate {
    constructor(page) {
      this.page = page;
    }
    /**
     * Retorna a data atual no formato 'MM/DD/AAAA'.
     * @returns {string} - A data atual no formato 'MM/DD/AAAA'.
     */
    async pegaDataAtualComBarrasMesDiaAno() {
      return moment().format('MM/DD/YYYY');
    }
    /**
    * Função para obter uma data com um deslocamento de dias, meses e anos específicos.
    * @param {number} dias - A quantidade de dias para adicionar (pode ser negativo para datas anteriores).
    * @param {number} meses - A quantidade de meses para adicionar (pode ser negativo para meses anteriores).
    * @param {number} anos - A quantidade de anos para adicionar (pode ser negativo para anos anteriores).
    * @param {boolean} formato - O formato da data (false para 'dd/mm/yyyy' e true para 'yyyy-mm-dd').
    * @return {string} - A data formatada.
    */
    pegaDataComBarras() {
      let dias = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let meses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let anos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let formato = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      let dataAtual = new Date();
      dataAtual = addDays(dataAtual, dias);
      dataAtual = addMonths(dataAtual, meses);
      dataAtual = addYears(dataAtual, anos);
      if (formato) {
        return format(dataAtual, 'yyyy-MM-dd');
      }
      return format(dataAtual, 'dd/MM/yyyy');
    }
    /**
      * Função que converte data formato americano para data formato brasileiro
      * @param {string} data data que deve ser convertida
      * @return data no formato brasileiro
      */
    formataDataBrasil(data) {
      return moment(data, 'YYYY-MM-DD').format('DD/MM/YYYY');
    }
    /**
    * Função que retorna por extenso a data atual.
    * @param {string} formato qual o formato de data deve retornar.
    */
    async transformarDataAtualExtenso(formato) {
      const dataAtual = new Date();
      if (formato === 'extenso') {
        return format(dataAtual, 'd \'de\' MMMM \'de\' yyyy', {
          locale: ptBR
        }); // 28 de novembro de 2020
      }
      return format(dataAtual, 'MMMM yyyy', {
        locale: ptBR
      }); // Novembro 2020
    }
    /**
      * Função que retorna por extenso uma data específicas.
      * @param {string} dataEspecificas qual a data que deve ser transformada em extenso
      * @param {string} formato qual o formato de data deve retornar
      */
    async transformarDataExtenso(dataEspecificas, formato) {
      const data = parse(dataEspecificas, 'dd/MM/yyyy', new Date());
      if (formato === 'extenso') {
        return format(data, 'd \'de\' MMMM \'de\' yyyy', {
          locale: ptBR
        }); // 28 de novembro de 2020
      }
      const mesAno = format(data, 'MMMM yyyy', {
        locale: ptBR
      }); // novembro 2020
      return mesAno.replace(/^(.)/, mesAno[0].toUpperCase()); // Novembro 2020
    }

    /**
     * busca a data atual da máquina e retorna no formato AAAA-MM-DDTHH:MM:SSZ
    */
    async getCurrentDateTime() {
      const numeroMinimoCaracteres = 2;
      const date = new Date();
      const time = date.toISOString().split('T')[1].split('.')[0];
      return `${date.getFullYear()}-` + `${(date.getMonth() + 1).toString().padStart(numeroMinimoCaracteres, '0')}-` + `${date.getDate().toString().padStart(numeroMinimoCaracteres, '0')}T` + `${time}Z`;
    }

    /**
     * Ajusta a data atual com base nos parâmetros fornecidos e o formata.
     *
     * @param {Object} options - Os parâmetros de ajuste da data.
     * @param {number} [options.dias=0] - Número de dias a ajustar.
     * @param {number} [options.meses=0] - Número de meses a ajustar.
     * @param {number} [options.anos=0] - Número de anos a ajustar.
     * @param {number} [options.horas=0] - Número de horas a ajustar.
     * @param {number} [options.minutos=0] - Número de minutos a ajustar.
     * @param {number} [options.segundos=0] - Número de segundos a ajustar.
     * @param {boolean} [options.formato=false] - Se true, retorna a data no formato 'yyyy-MM-dd HH:mm:ss', caso contrário 'dd/MM/yyyy HH:mm:ss'.
     * @returns {string} A data ajustada e formatada.
    */

    pegaDataHoraAtualComBarras() {
      let {
        dias = 0,
        meses = 0,
        anos = 0,
        horas = 0,
        minutos = 0,
        segundos = 0,
        formato = false
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let dataAtual = new Date();
      dataAtual = addDays(dataAtual, dias);
      dataAtual = addMonths(dataAtual, meses);
      dataAtual = addYears(dataAtual, anos);
      dataAtual = addHours(dataAtual, horas);
      dataAtual = addMinutes(dataAtual, minutos);
      dataAtual = addSeconds(dataAtual, segundos);
      const formatoDesejado = formato ? 'yyyy-MM-dd HH:mm:ss' : 'dd/MM/yyyy HH:mm:ss';
      return format(dataAtual, formatoDesejado);
    }
  }

  exports.DataUtils = DataUtils;
  exports.FormatDate = FormatDate;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
