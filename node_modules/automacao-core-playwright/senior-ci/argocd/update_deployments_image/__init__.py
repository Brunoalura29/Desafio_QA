from datetime import datetime
from typing import NoReturn

from colorama import Fore
from gitlab import const
from gitlab.exceptions import GitlabGetError
from yaml import Dumper, dump

from argocd import ArgoCDCenter, helper
from common import (
    end_collapsible_section,
    exit_message,
    get_commit_tag_as_semver,
    get_env_variable_required,
    get_last_version,
    print_message,
    repository_is_sdl_flex,
    start_collapsible_section,
)
from common.file_helpers import get_svc_name


class UpdateDeploymentsImage(ArgoCDCenter):
    """
    Atualiza as imagens dos deployments do serviço para a versão que está sendo executada.

    Se não for executado em uma tag será atualizado para uma versão SNAPSHOT do branch.
    """

    def __init__(self) -> NoReturn:
        super().__init__()

        gitlab_user_name = get_env_variable_required("GITLAB_USER_NAME")

        ci_commit_tag_semver = get_commit_tag_as_semver()
        ci_commit_ref_slug = get_env_variable_required("CI_COMMIT_REF_SLUG")
        ci_project_name = get_env_variable_required("CI_PROJECT_NAME")
        sci_project_type = get_env_variable_required("SCI_PROJECT_TYPE")

        must_start_numerical_types = ["DOTNET6_APP"]
        implementable_environments = ["homologx", "beta"]

        svc_name = get_svc_name()

        if not svc_name:
            exit_message(
                "Não foi possível encontrar o nome da imagem do serviço. "
                "Por favor entre com contato com a equipe DevOps."
            )

        image_name = (
            f"seniorsa/{svc_name}-http"
            if repository_is_sdl_flex() and "flex" in self.manifest_project.name
            else f"seniorsa/{svc_name}"
        )
        version = f"{ci_commit_ref_slug}-SNAPSHOT"

        if ci_commit_tag_semver:
            version = ci_commit_tag_semver
        elif sci_project_type in must_start_numerical_types:
            last_version = get_last_version()

            if last_version:
                version = f"{last_version}-{version}"
            else:
                version = f"0.0.0-{version}"

        section_id = start_collapsible_section(
            f'Começando processo de atualização da imagem "{image_name}" para a versão "{version}" '
            f"no repositório {self.manifest_project.name}.",
            Fore.CYAN,
        )

        print_message(f'Procurando manifestos que possuem a imagem "{image_name}"...')

        blobs_result_search = self.manifest_project.search(
            const.SEARCH_SCOPE_BLOBS, f"{image_name}:"
        )

        manifest_was_implemented = False

        if not blobs_result_search:
            environment = self.manifest_project.name.split("-")[0]
            if self.leaf_manifest_project and environment in implementable_environments:
                manifest_was_implemented = self.copy_deployment_from_leaf(
                    image_name, svc_name
                )
            else:
                exit_message(
                    f'Não foi encontrado nenhum manifesto para atualização da imagem "{image_name}"',
                )

        print_message(
            f"Foram encontrados {len(blobs_result_search)} manifestos"
            if not manifest_was_implemented
            else "Não foram encontrados nenhum manifesto"
        )
        print(" ")

        deploy_branch = f"deploy/{ci_project_name}-{ci_commit_ref_slug}"

        try:
            svc_branch = self.manifest_project.branches.get(deploy_branch)

            print_message(
                f'Recriando branch "{deploy_branch}" no projeto de manifestos...'
            )
            if svc_branch:
                svc_branch.delete()

            self.manifest_project.branches.create(
                {
                    "branch": deploy_branch,
                    "ref": self.ci_default_branch,
                    "commit_message": f"Branch criada por {gitlab_user_name}",
                }
            )
        except GitlabGetError:
            print_message(
                f'Criando branch "{deploy_branch}" no projeto de manifestos...'
            )
            self.manifest_project.branches.create(
                {
                    "branch": deploy_branch,
                    "ref": self.ci_default_branch,
                    "commit_message": f"Branch criada por {gitlab_user_name}",
                }
            )

        print(" ")
        print_message(
            "Começando a atualização das versões..."
            if not manifest_was_implemented
            else f"Começando a implantação do serviço {svc_name}..."
        )

        commit_actions = []

        now_timestamp = datetime.now().strftime("%s")

        for blob in blobs_result_search:
            file_path = blob["path"]
            filename = file_path.split("/").pop()

            deployment_yaml = self.get_yaml_by_path(file_path)

            deployment_template = deployment_yaml["spec"]["template"]
            deployment_metadata = deployment_template["metadata"]

            deployment_template["spec"]["containers"][0][
                "image"
            ] = f"{image_name}:{version}"

            if deployment_metadata.get("annotations"):
                deployment_metadata["annotations"]["timestamp"] = now_timestamp
            else:
                deployment_metadata.update(
                    {"annotations": {"timestamp": now_timestamp}}
                )

            commit_actions.append(
                {
                    "action": "update",
                    "file_path": file_path,
                    "content": dump(deployment_yaml, Dumper=Dumper),
                }
            )

            print_message(
                f'O arquivo "{filename}" será atualizado com a nova imagem "{image_name}:{version}"'
            )

        data = {
            "branch": deploy_branch,
            "commit_message": f"Sincronização solicitada por {gitlab_user_name}",
            "actions": commit_actions,
        }

        self.manifest_project.commits.create(data)

        print(" ")
        print_message(
            (
                "Todos os arquivos foram atualizados com sucesso, o deploy deles será feito no próximo job!"
                if not manifest_was_implemented
                else f"O serviço {svc_name} foi implantado com sucesso, O deploy será feito no próximo job!"
            ),
            Fore.GREEN,
        )

        end_collapsible_section(section_id)
