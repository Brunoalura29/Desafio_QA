"""Module for common methods used on entire application"""

import os
import random
import string
import sys
from datetime import datetime
from enum import Enum
from glob import glob
from re import match
from subprocess import PIPE, STDOUT, Popen
from typing import List, NoReturn

from colorama import Back, Fore, Style
from packaging.version import InvalidVersion, parse


class ExitCode(Enum):
    SUCCESS = 0
    ERROR = 1


class Command(object):
    output = ""
    cmd: str
    exit_code: ExitCode

    def __init__(self, cmd: str, error_message: str):
        self.cmd = cmd
        self.error_message = error_message

    def run(self, print_command=True, print_output=True):
        if print_command:
            print_message(self.cmd, Fore.LIGHTGREEN_EX)

        with Popen(
            self.cmd,
            stdout=PIPE,
            stderr=STDOUT,
            shell=True,
        ) as process:
            if print_output:
                print(" ")

            while True:
                line = process.stdout.readline()
                if not line:
                    break

                self.output += line.decode()

                if print_output:
                    print(line.decode().replace("\n", ""))

            exit_code = process.wait()

            self._set_exit_code(exit_code)

            if self.error_message and self.exit_code == ExitCode.ERROR:
                exit_message(self.error_message)

            return self

    def _set_exit_code(self, exit_code: int):
        if exit_code == 0 or (exit_code == 65 and "flutter pub" in self.cmd):
            self.exit_code = ExitCode.SUCCESS
        else:
            self.exit_code = ExitCode.ERROR


def get_env_variable(variable_name: str, default_value: str = None) -> str:
    """Get the environment variable"""

    var = os.getenv(variable_name)

    if not var:
        var = default_value

    return var


def get_env_variable_required(variable_name: str) -> str:
    """Get the environment variable and check if exist"""

    var = get_env_variable(variable_name)

    if not var:
        exit_message(f"Variável obrigatória não informada: {variable_name}")

    return var


def convert_tag_to_semver(tag: str) -> str:
    """Convert a Gitlab Tag to semver format (vX-Y-Z => X.Y.Z)"""

    return tag.replace("v", "").replace("-", ".")


def get_commit_tag_as_semver() -> str or None:
    """Get version from gitlab variable CI_COMMIT_TAG
    and format it to semver format (vX-Y-Z => X.Y.Z)
    """

    commit_tag = get_env_variable("CI_COMMIT_TAG")

    return convert_tag_to_semver(commit_tag) if commit_tag else None


def get_version_from_gitlab() -> str:
    """
    DEPRECATED

    Use directly `get_version()`
    """

    return get_version()


def get_version() -> str:
    """Get version from gitlab variables

    Get the tag if running from a tag or
    add the branch name and SNAPSHOT
    """

    version = get_commit_tag_as_semver()

    if not version:
        commit_ref_slug = get_env_variable_required("CI_COMMIT_REF_SLUG")

        version = f"{commit_ref_slug}-SNAPSHOT"

    return version


def print_message(message: str, fore_color=None) -> NoReturn:
    """Print a colored message"""

    colored_message = get_colored_message(message, fore_color)

    print(colored_message)


def print_messages(messages: List[str], fore_color=None) -> NoReturn:
    """Print many colored messages"""

    for message in messages:
        print_message(message, fore_color)


def get_colored_message(
    message, fore_color: Fore = None, back_color: Back = None
) -> str:
    """Color a message"""

    fore_color_code = fore_color if fore_color else ""
    back_color_code = back_color if back_color else ""

    reset_style_code = Style.RESET_ALL if back_color or fore_color else ""

    return f"{back_color_code}{fore_color_code}[CI] {message}{reset_style_code}"


def start_collapsible_section(header: str, fore_color: Fore = None) -> str:
    """Print a message with the GitLab syntax to create a collapse section
    and return the id for use when close the section

    https://docs.gitlab.com/ee/ci/jobs/index.html#custom-collapsible-sections
    """

    section_id = "".join(random.choices(string.ascii_uppercase + string.digits, k=10))

    colored_header = get_colored_message(header, fore_color)

    print(" ")
    print(
        f"\033[0Ksection_start:{datetime.utcnow().strftime('%s')}:{section_id}\r\033[0K{colored_header}"
    )
    print(" ")

    return section_id


def end_collapsible_section(section_id: str) -> NoReturn:
    """Close the section"""

    print(
        f"\033[0Ksection_end:{datetime.utcnow().strftime('%s')}:{section_id}\r\033[0K"
    )


def exit_message(message: str) -> NoReturn:
    """Print a red error message and stop the execution"""

    print(" ")
    print_message(message, Fore.LIGHTRED_EX)
    sys.exit(2)


def exec_command(
    command: str,
    print_command=True,
    print_output=True,
    error_message: str = None,
) -> Command:
    """Run a command"""

    cmd = Command(command, error_message)

    return cmd.run(print_command, print_output)


def cd_path(path: str) -> NoReturn:
    """Print a path then navigate"""

    print_message(f"Navigating to path: {path}")

    os.chdir(path)


def unshallow_repo() -> NoReturn:
    """Get all references of repository"""

    print_message("Atualizando repositório git com todas as referências")

    is_shallow = exec_command(
        "git rev-parse --is-shallow-repository", print_output=False
    )

    if is_shallow.output.rstrip() == "true":
        exec_command("git fetch --unshallow", print_output=False)

    exec_command("git fetch --all", print_output=False)

    print_message("Repositório atualizado")


def is_path_exist(path: str) -> bool:
    """Validate the existence of a path"""

    return os.path.exists(path)


def regex_path_exists(path: str) -> bool:
    return len(glob(path)) > 0


def is_frontend() -> bool:
    """Verify if project is frontend"""

    ci_project_name = get_env_variable_required("CI_PROJECT_NAME")
    sci_project_type = get_env_variable_required("SCI_PROJECT_TYPE")

    return (
        sci_project_type in ["ANGULAR_SENIORX", "ANGULAR_GENERATED", "ANGULAR_APP"]
        or "-frontend" in ci_project_name
    )


def get_last_version():
    """Returns last released version tag"""
    unshallow_repo()

    version = exec_command(
        "git describe --tags --abbrev=0", print_output=False
    ).output.strip()

    version_converted = convert_tag_to_semver(version)

    return version_converted if is_semver(version_converted) else None


def is_semver(version: str):
    """Validate string is semantic version"""

    try:
        parse(version)
        return True
    except InvalidVersion:
        return False


def repository_is_flex() -> bool:
    """Check if the repository is flex or not"""

    sci_flex = get_env_variable("SCI_FLEX")

    return bool(sci_flex)


def repository_is_sdl_flex() -> bool:
    """Check if the repository is sdl and flex or not"""

    sci_project_type = get_env_variable_required("SCI_PROJECT_TYPE")

    return "MAVEN_SDL" in sci_project_type and repository_is_flex()
