"""Scripts for DotNet APPS"""

import os
import re
import shutil
from pathlib import Path

from colorama import Fore

from common import exec_command, exit_message, get_env_variable_required, print_message
from docker import push_image
from dotnet import BaseDotNetCI


class DotNetAppsCI(BaseDotNetCI):
    def exec_ci(self):
        for opt, arg in self.opts:
            if opt == "-v":
                self.validation()
            elif opt == "-r":
                self._release_app(arg)
            elif opt == "-p":
                self._publish_app()
            elif opt == "-x":
                self.run_sonar()
            elif opt == "-g":
                self._generate_template(arg)
            else:
                exit_message("É preciso informar a opção referente a ação escolhida")

    def compile(self, version):
        self.configure_nuget()

        print_message("Compilando projeto.")

        # Executa build
        exec_command(
            f"dotnet publish --no-self-contained -c release -o output/ -p:version={version}",
            error_message="Compilação finalizada com erro.",
        )

        print_message("Compilação finalizada com sucesso.", Fore.GREEN)

    def _release_app(self, versioning_release: str):
        if versioning_release == "snapshot":
            version = self.get_version()

            self._publish_app(version)
        else:
            self.release(versioning_release)

    def _publish_app(self, version: str = None):
        if not version:
            version = self.get_version()

        print_message(f"Publicando versão {version}")

        self.compile(version)

        push_image(version)

    def _generate_template(self, service_name: str = None):
        print_message("Gerando templates do microsserviço.")

        service_words = service_name.strip().split("-")
        service_name = ".".join(word.capitalize() for word in service_words)

        self.configure_nuget()

        exec_command(
            "dotnet new --install Senior.Templates",
            print_command=False,
            print_output=False,
        )

        exec_command(f"dotnet new senior -o {service_name}")

        self._replace_repository_with_generated_template(service_name)
        self._commit_changes()

        print_message("Seu microsserviço foi gerado com sucesso, bom trabalho!")

    def _replace_repository_with_generated_template(self, output_dir: str):
        preserved_files = {
            "README.md",
            "CHANGELOG.md",
            ".gitlab-ci.yml",
            "senior-ci",
            output_dir,
        }

        repo_root = os.getcwd()
        preserved_paths = {os.path.join(repo_root, file) for file in preserved_files}

        self.clean_dirs(repo_root, preserved_paths)

        self.copy_dirs(output_dir, repo_root)
        shutil.rmtree(output_dir)
        os.rename(f"{output_dir}-temp", output_dir)

    def copy_dirs(self, output_dir, repo_root):
        for item in os.listdir(output_dir):
            source_path = os.path.join(output_dir, item)
            destination_path = os.path.join(repo_root, item)

            if os.path.isdir(source_path):
                if item == output_dir:
                    destination_path = os.path.join(repo_root, f"{item}-temp")
                shutil.copytree(source_path, destination_path)
            else:
                shutil.copy2(source_path, destination_path)

    def clean_dirs(self, repo_root, preserved_paths):
        for item in os.listdir(repo_root):
            item_path = os.path.join(repo_root, item)
            if item_path not in preserved_paths and item != ".git":
                if os.path.isfile(item_path) or os.path.islink(item_path):
                    os.remove(item_path)
                elif os.path.isdir(item_path):
                    shutil.rmtree(item_path)

    def _commit_changes(self):
        ci_project_dir = get_env_variable_required("CI_PROJECT_DIR")
        ci_repo_url = get_env_variable_required("CI_REPOSITORY_URL")
        exec_command("git checkout -B feature/init")
        ci_repo_url = re.sub(r".*@(.+)", r"git@\1", ci_repo_url)
        ci_repo_url = re.sub(r"/", ":", ci_repo_url, count=1)
        print(ci_repo_url)

        dirs_to_remove = [".npm", ".cache", ".m2", "**/.npm", "**/.cache", "**/.m2"]
        root_dir = Path.cwd()
        for pattern in dirs_to_remove:
            for path in root_dir.glob(pattern):
                if path.is_dir():
                    shutil.rmtree(path, ignore_errors=True)
        exec_command("git add -A")
        exec_command(
            f"git reset {ci_project_dir}/senior-ci/ {ci_project_dir}/venv/ senior-ci/ venv/ **/senior-ci/ **/venv/"
        )
        exec_command("git commit -m '[CI] Primeiras fontes gerados do microsserviço.'")
        exec_command(f"git remote set-url --push origin '{ci_repo_url}'")
        exec_command("git status")
        exec_command("git checkout develop")
        exec_command("git merge feature/init --allow-unrelated-histories")
        exec_command("git status")
        exec_command("git push")
