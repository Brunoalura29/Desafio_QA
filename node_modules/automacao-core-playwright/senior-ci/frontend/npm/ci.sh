#!/bin/bash

set -e # Exit at first error

echo "----------------------------------------------------------------------------------"
echo "[CI] Variáveis:"
echo "[CI] - SCI_VERSION=$SCI_VERSION"
echo "[CI] - BUCKET_NAME=$BUCKET_NAME"
echo "[CI] - CANNED_ACL=$CANNED_ACL"
echo "[CI] - TRANSLATIONS_USER=$TRANSLATIONS_USER"
echo "[CI] - TENANT=$TENANT"
echo "[CI] - DOMAIN=$DOMAIN"
echo "[CI] - SERVICE=$SERVICE"
echo "[CI] - SLACK_HOOK=$SLACK_HOOK"
echo "[CI] - BRANCH/TAG: $CI_COMMIT_REF_SLUG"
echo "[CI] - NOME DO PROJETO: $CI_PROJECT_NAME"
echo "[CI] - ID DO PROJETO: $CI_PROJECT_ID"
echo "----------------------------------------------------------------------------------"


MESSAGE_HELP="Caso tenha qualquer dúvida sobre o processo, consulte nossa Wiki - https://git.senior.com.br/devops/senior-ci/wikis/home"

# Import release helpers
. senior-ci/common/release-helpers.sh

# Import notification helpers
. senior-ci/common/notification-helpers.sh

# Senior CI Extensions
. senior-ci/common/senior-ci-extensions-helpers.sh

# Import npm struture helpers
. senior-ci/common/npm-helper.sh

# Import docker helpers
. ./senior-ci/common/docker-helpers.sh

publish_frontend(){
    : "${BUCKET_NAME:?BUCKET_NAME não configurado no cluster.}"
    : "${CANNED_ACL:?CANNED_ACL não configurado no cluster.}"

    APP_NAME=$(get_attribute "app\":")
    DOMAIN=$(get_attribute "domain\":")
    SERVICE=$(get_attribute "service\":")

    echo "[CI] Buildando o projeto."
    if [ "$DEPLOY_CDN" = "true" ]; then
      npm run build --production -- --deploy-url $CLOUDFRONT_URL/$APP_NAME/$DOMAIN/$SERVICE/$VERSION/
    else
      npm run build --production
    fi

    echo "[CI] Criando arquivo dist/frontend-info.json"
    echo "console.log(JSON.stringify(require('./package.json').project, null, 2))" | node | sed "s,^{,{\n  \"version\":\"$VERSION\"\,," > dist/frontend-info.json

    echo "[CI] Iniciando publicação da versão $VERSION para o AWS S3"

    tar -zcf frontend.tar.gz -C dist .
    PROJECT=$(get_attribute "name\":")

    echo "[CI] Publicando backup da versão $VERSION no bucket s3://senior-frontend/$PROJECT/$VERSION"
    tar -zcf $PROJECT.tar.gz dist --transform s/dist/$PROJECT/
    aws s3 cp $PROJECT.tar.gz s3://senior-frontend/$PROJECT/$VERSION/ --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers

    echo "[CI] Publicando a versão $VERSION no bucket s3://$BUCKET_NAME/$APP_NAME/$DOMAIN/$SERVICE/$VERSION onde ficará disponível para o Senior X Frontend Updater."
    mv frontend.tar.gz ./dist/
    aws s3 cp dist s3://$BUCKET_NAME/$APP_NAME/$DOMAIN/$SERVICE/$VERSION/ --recursive --acl $CANNED_ACL

    if [ "$DEPLOY_CDN" = "true" ]; then
      upload_to_cdn
    fi
}

packing() {
    echo "[CI] Iniciando processo de publicação do projeto."

    call_extension "before_packing"

    if [[ -z "${NO_FRONTEND}" ]]; then
        publish_frontend
    fi

    call_extension "after_packing"
}

build_to_cdn() {
  APP_NAME=$(get_attribute "app\":")
  DOMAIN=$(get_attribute "domain\":")
  SERVICE=$(get_attribute "service\":")

  BUILD_VERSION="${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG-SNAPSHOT}"

  npm run build -- --deploy-url $CLOUDFRONT_URL/$APP_NAME/$DOMAIN/$SERVICE/$BUILD_VERSION/
}

upload_to_cdn() {
  CLOUDFRONT_PATH="/$APP_NAME/$DOMAIN/$SERVICE/$VERSION/"
  BUCKET_PATH="s3://$CLOUFRONT_BUCKET$CLOUDFRONT_PATH"
  echo "[CI] Publicando os assets/libs da versão $VERSION no bucket $BUCKET_PATH"
  TEMP_AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
  TEMP_AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY

  unset AWS_ACCESS_KEY_ID
  unset AWS_SECRET_ACCESS_KEY

  AWS_CREDENTIALS=$(aws sts assume-role --role-arn ${CLOUDFRONT_ROLE_ARN} --role-session-name "CDNFrontendUploader" --output json)

  CLOUDFRONT_ACCESS_KEY_ID=$(echo $AWS_CREDENTIALS|jq '.Credentials.AccessKeyId'|tr -d '"')
  CLOUDFRONT_SECRET_ACCESS_KEY=$(echo $AWS_CREDENTIALS|jq '.Credentials.SecretAccessKey'|tr -d '"')
  CLOUDFRONT_SESSION_TOKEN=$(echo $AWS_CREDENTIALS|jq '.Credentials.SessionToken'|tr -d '"')

  export AWS_ACCESS_KEY_ID=$CLOUDFRONT_ACCESS_KEY_ID
  export AWS_SECRET_ACCESS_KEY=$CLOUDFRONT_SECRET_ACCESS_KEY
  export AWS_SESSION_TOKEN=$CLOUDFRONT_SESSION_TOKEN

  aws s3 cp dist "$BUCKET_PATH" --recursive --exclude frontend.tar.gz
  echo "[CI] Invalidando caminho $CLOUDFRONT_PATH na distribuição $CLOUFRONT_DISTRIBUTION_ID "
  aws cloudfront create-invalidation --distribution-id $CLOUFRONT_DISTRIBUTION_ID --paths "$CLOUDFRONT_PATH*"

  export AWS_ACCESS_KEY_ID=$TEMP_AWS_ACCESS_KEY_ID
  export AWS_SECRET_ACCESS_KEY=$TEMP_AWS_SECRET_ACCESS_KEY
}

getopts "bsrpdcxt" op;
case "$op" in

  b)  echo "[CI] Executando compilação e validação de formatação do código"
      python3 senior-ci/common/validations/changelog
      python3 senior-ci/common/validations/issues

      install

      call_extension "before_build"
      if [ "$DEPLOY_CDN" = "true" ]; then
        build_to_cdn
      else
        npm run build
      fi
      npm run lint --if-present

      call_extension "after_build"
      ;;

  s)  echo "[CI] Realizando release: SNAPSHOT"
      install

      call_extension "before_release_snapshot"
      VERSION="$2-SNAPSHOT"
      packing
      call_extension "after_release_snapshot"
      ;;

  r)  echo "[CI] Realizando release: $2"
      python3 senior-ci/common/validations/issues

      unshallow_repo

      get_next_version $2

      call_extension "before_release"

      create_release_branch

      npm version --no-git-tag-version "$VERSION"
      [[ -f bower.json ]] && sed -i -E "s/(\"version\":[[:space:]]*\").+(\")/\1${VERSION}\2/g" bower.json

      call_extension "before_change_changelog"

      update_changelog

      call_extension "after_change_changelog"

      create_release_tag

      call_extension "after_release"

      echo "[CI] Criação da release versão $VERSION realizado com sucesso. Execute o job 'package' para publicar esta versão no AWS S3."

      notify_release_teams_channel
      ;;

  p)  echo "[CI] Publicação da versão"
      install

      call_extension "before_packaging"

      VERSION=$(git describe --exact-match --tags | sed "s/-\([[:digit:]]\)/\.\1/g")
      if [ -z "${VERSION}" ]; then
        VERSION=$(get_attribute "version\":")
      fi

      packing

      USER_DEPLOY_MAIL="${GITLAB_USER_EMAIL%@senior.com.br}"
      MESSAGE_DEPLOY="O usuário $USER_DEPLOY_MAIL liberou a versão $VERSION do projeto $CI_PROJECT_NAME. Changelog: $CI_PROJECT_URL/blob/$CI_COMMIT_REF_NAME/CHANGELOG.md"

      call_extension "after_packaging"

      notify_text_teams_channel "$MESSAGE_DEPLOY"

      echo "[CI] Versão $VERSION publicada no AWS S3 com sucesso!"
      ;;

  d)  echo "[CI] Iniciando deploy"

      call_extension "before_deploy"
      : "${CI_ENVIRONMENT_URL:?Configure as propriedades name e url do grupo environment no .gitlab-ci.yml. $MESSAGE_HELP}"
      : "${DEPLOY_USERNAME:?Configure a variável DEPLOY_USERNAME no cluster. $MESSAGE_HELP}"
      : "${DEPLOY_PASSWORD:?Configure a variável DEPLOY_PASSWORD no cluster. $MESSAGE_HELP}"

      APP_NAME=$(get_attribute "app\":")
      DOMAIN_NAME=$(get_attribute "domain\":")
      SERVICE_NAME=$(get_attribute "service\":")

      : "${APP_NAME:?Adicione no package.json a chave app com o nome da sua aplicação. $MESSAGE_HELP}"
      : "${DOMAIN_NAME:?Adicione no package.json a chave domain com o nome do domínio. $MESSAGE_HELP}"
      : "${SERVICE_NAME:?Adicione no package.json a chave service com o nome do serviço. $MESSAGE_HELP}"

      CI_COMMIT_TAG="${CI_COMMIT_TAG//-/.}"
      VERSION="${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG-SNAPSHOT}"

      echo "[CI] Realizando login na Senior X Platform - Ambiente $CI_ENVIRONMENT_URL"
      TOKEN=$(curl -s -X POST "$CI_ENVIRONMENT_URL/platform/authentication/actions/login" -H "Content-Type: application/json" --insecure -d '{ "username": "'$DEPLOY_USERNAME'", "password": "'$DEPLOY_PASSWORD'"}' ${CI_DEBUG_TRACE:+--trace-ascii /dev/stderr} | jq --raw-output '.jsonToken | fromjson | "Authorization: " + .token_type + " " + .access_token')

      DEPLOY_INFO=$(curl -s "$CI_ENVIRONMENT_URL/platform/frontend_updater/queries/listDeploy" --insecure -H "$TOKEN" ${CI_DEBUG_TRACE:+--trace-ascii /dev/stderr} | jq --arg APP_NAME "$APP_NAME" --arg DOMAIN_NAME "$DOMAIN_NAME" --arg SERVICE_NAME "$SERVICE_NAME" '.content | map(select(.appName == $APP_NAME and .domainName == $DOMAIN_NAME and .serviceName == $SERVICE_NAME)) | first')

    if [[ -z "$DEPLOY_INFO" || $DEPLOY_INFO == null ]]
      then
        : "${MENU_MODULE_ID:?Id do módulo de menu não definido. Não será possível implantar o frontend. $MESSAGE_HELP}"

        MENU_MODULE_NAME=$(curl -s "$CI_ENVIRONMENT_URL/platform/menu/queries/listModules?mapCustomModules=false&mapFrontendsConfiguration=false" -H "Content-Type: application/json" --insecure -H "$TOKEN" | jq -r '.modules[] | select(.id == "'$MENU_MODULE_ID'") | .name')

        : "${MENU_MODULE_NAME:?Módulo com o id $MENU_MODULE_ID não encontrado. Não será possível implantar o frontend. $MESSAGE_HELP}"

        echo "[CI] Frontend $APP_NAME.$DOMAIN_NAME.$SERVICE_NAME#$VERSION não encontrado no ambiente. Realizando implantação com o Frontend Updater ($CI_ENVIRONMENT_URL/platform/frontend_updater) no menu $MENU_MODULE_NAME"

        ORIGIN_ID=$(curl -s "$CI_ENVIRONMENT_URL/platform/frontend_updater/queries/listOrigins" -H "Content-Type: application/json" --insecure -H "$TOKEN" | jq '.content | .[] | select(.name == "Plataforma") | .id')
        TARGET_ID=$(curl -s "$CI_ENVIRONMENT_URL/platform/frontend_updater/queries/listTargets" -H "Content-Type: application/json" --insecure -H "$TOKEN" | jq '.content | .[0] | .id')

        DEPLOY_ALIAS="$APP_NAME/$DOMAIN_NAME/$SERVICE_NAME"

        curl -s -X POST "$CI_ENVIRONMENT_URL/platform/frontend_updater/actions/insertDeploy" -H "$TOKEN" -H "Content-Type: application/json" --insecure -d '{ "originId": '$ORIGIN_ID', "targetId": '$TARGET_ID', "appName": "'$APP_NAME'", "domainName": "'$DOMAIN_NAME'", "serviceName": "'$SERVICE_NAME'", "version": "'$VERSION'", "alias": "'$DEPLOY_ALIAS'", "moduleId": "'$MENU_MODULE_ID'"}' ${CI_DEBUG_TRACE:+--trace-ascii /dev/stderr} > /dev/null
      else
          echo "[CI] Atualizando frontend $APP_NAME.$DOMAIN_NAME.$SERVICE_NAME#$VERSION com o Frontend Updater - $CI_ENVIRONMENT_URL/platform/frontend_updater/"

          ORIGIN_ID=$(echo "$DEPLOY_INFO" | jq --raw-output '.origin.id')
          DEPLOY_ID=$(echo "$DEPLOY_INFO" | jq --raw-output '.deployId')
          DEPLOY_ALIAS=$(echo "$DEPLOY_INFO" | jq --raw-output '.alias')

          # Tecnicamente, não precisaria atualizar a origem para realizar o deploy. É feito só para a versão aparecer corretamente no frontend.
          curl -s -X POST "$CI_ENVIRONMENT_URL/platform/frontend_updater/signals/updateFrontends" --insecure -H "$TOKEN" -H "Content-Type: application/json" -d '{ "originId": "'$ORIGIN_ID'" }' ${CI_DEBUG_TRACE:+--trace-ascii /dev/stderr} > /dev/null
          curl -s -X POST "$CI_ENVIRONMENT_URL/platform/frontend_updater/actions/updateDeploy" --insecure -H "$TOKEN" -H "Content-Type: application/json" -d '{ "deployId": "'$DEPLOY_ID'", "version": "'$VERSION'" }' ${CI_DEBUG_TRACE:+--trace-ascii /dev/stderr} > /dev/null
      fi

      USER_DEPLOY_MAIL="${GITLAB_USER_EMAIL%@senior.com.br}"
      MESSAGE_DEPLOY="O usuário $USER_DEPLOY_MAIL alterou o frontend $APP_NAME.$DOMAIN_NAME.$SERVICE_NAME ($CI_PROJECT_NAME) para a versão <$CI_PROJECT_URL/blob/$CI_COMMIT_REF_NAME/CHANGELOG.md#anchor-$VERSION_WITHOUT_DOTS|$VERSION>."

      call_extension "after_deploy"

      notify_text_teams_channel "$MESSAGE_DEPLOY"

      echo "[CI] Deploy realizado com sucesso!"
      ;;

  c)  echo "[CI] Publicação da versão"

      unset AWS_ACCESS_KEY_ID
      unset AWS_SECRET_ACCESS_KEY

      : "${SCI_CDN_ACCOUNT_ID:?Configure a variável SCI_CDN_ACCOUNT_ID no projeto. $MESSAGE_HELP}"
      : "${SCI_CDN_BUCKET_NAME:?Configure a variável SCI_CDN_BUCKET_NAME no projeto. $MESSAGE_HELP}"
      : "${SCI_CDN_DISTRIBUTION_ID:?Configure a variável SCI_CDN_DISTRIBUTION_ID no projeto. $MESSAGE_HELP}"

      AWS_CREDENTIALS=`aws sts assume-role --role-arn arn:aws:iam::$SCI_CDN_ACCOUNT_ID:role/CDNFrontendUploader --role-session-name "CDNFrontendUploader" --output json`

      CDN_ACCESS_KEY_ID=`echo $AWS_CREDENTIALS | jq -r '.Credentials.AccessKeyId'`
      CDN_SECRET_ACCESS_KEY=`echo $AWS_CREDENTIALS | jq -r '.Credentials.SecretAccessKey'`
      CDN_SESSION_TOKEN=`echo $AWS_CREDENTIALS | jq -r '.Credentials.SessionToken'`

      export AWS_ACCESS_KEY_ID=$CDN_ACCESS_KEY_ID
      export AWS_SECRET_ACCESS_KEY=$CDN_SECRET_ACCESS_KEY
      export AWS_SESSION_TOKEN=$CDN_SESSION_TOKEN

      install

      call_extension "before_packaging"

      CI_COMMIT_TAG="${CI_COMMIT_TAG/v/}"
      CI_COMMIT_TAG="${CI_COMMIT_TAG/-/.}"
      VERSION="${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG-SNAPSHOT}"

      echo "[CI] Buildando o projeto para produção."
      npm run build --production

      echo "[CI] Publicando a versão $VERSION no bucket $SCI_CDN_BUCKET_NAME"
      aws s3 sync ./dist s3://$SCI_CDN_BUCKET_NAME/ --delete

      echo "[CI] Invalidando index.html no cdn $SCI_CDN_DISTRIBUTION_ID"
      aws cloudfront create-invalidation --distribution-id $SCI_CDN_DISTRIBUTION_ID --paths /index.html >> null

      USER_DEPLOY_MAIL="${GITLAB_USER_EMAIL%@senior.com.br}"
      MESSAGE_DEPLOY="O usuário $USER_DEPLOY_MAIL liberou a versão $VERSION do projeto $CI_PROJECT_NAME. Changelog: $CI_PROJECT_URL/blob/$CI_COMMIT_REF_NAME/CHANGELOG.md"

      call_extension "after_packaging"

      notify_text_teams_channel "$MESSAGE_DEPLOY"

      echo "[CI] Versão $VERSION publicada no AWS S3 com sucesso!"
      ;;

  x)  echo "[CI] Realizando validação de testes e análise no SonarQube"
      python3 senior-ci/common/validations/issues
      SKIP_BUILD=`python3 senior-ci/common/validations/buildable`

      call_extension "before_build"

      if [ "$SKIP_BUILD" = "False" ]; then
        install
        npm test
      fi

      call_extension "after_build"

      python3 senior-ci/ci/sonar_scanner.py -s $SKIP_BUILD
      ;;

  t)  echo "[CI] Iniciando processo de Release Translations"
      senior-ci/frontend/npm/release-translations.sh
      ;;

  esac
