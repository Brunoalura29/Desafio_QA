import sys

sys.path.append("./senior-ci")

import json
import re
from abc import ABC, abstractmethod
from pathlib import Path

from colorama import Fore
from typing_extensions import List, Literal

from common import exit_message, get_env_variable, print_message
from common.file_helpers import load_properties


class TranslationFile:
    path: Path
    language: str
    content: dict
    raw_content: str

    def __init__(self, path, content):
        lan_pattern = re.compile(r"([a-z]{2}[-_][A-Z]{2})(?=\.(properties|json))")

        lan_match = lan_pattern.search(path.name)

        self.path = path
        self.content = content
        self.language = lan_match[0].replace("_", "-") if lan_match else None
        self.raw_content = path.read_text()


class TranslationRepository(ABC):
    file_extension: Literal[".json", ".properties"]
    file_format: Literal["FLAT_JSON", "PROPERTIES"]
    translations_dir: Path
    files: List[TranslationFile]

    def __init__(self):
        self.translations_dir = Path(
            get_env_variable("SCI_TRANSLATIONS_DIR", self.translations_dir)
        )

        if not self.translations_dir.is_dir():
            exit_message(
                f"O caminho das traduções não é um diretório válido. "
                f"Caso o seu projeto use um diretório diferente de '{self.translations_dir}' você pode "
                "configurar a variável SCI_TRANSLATIONS_DIR com o diretório correto."
            )

        self.files = self._get_translation_files()

        if not self.files:
            exit_message(
                f"Nenhum arquivo de tradução foi encontrado. "
                f"Caso o seu projeto use um diretório diferente de '{self.translations_dir}' você pode "
                "configurar a variável SCI_TRANSLATIONS_DIR com o diretório correto."
            )

    def check_translation_key_violation(self):
        do_contain_violations = False

        all_translations_keys = self._load_all_translations_keys()

        for translation_file in self.files:
            if do_contain_violations:
                print(" ")
            print_message(
                f"Verificando chaves de tradução do arquivo {translation_file.path}"
            )
            for key in all_translations_keys:
                if self._is_valid_key(key) and not translation_file.content.get(key):
                    print_message(
                        f"Chave não declarada no arquivo: {key}",
                        fore_color=Fore.RED,
                    )
                    do_contain_violations = True
        return do_contain_violations

    def _is_valid_key(self, key: str):
        pattern = re.compile(r"^[a-zA-Z0-9_\\.-]+$")
        return pattern.match(key)

    def _load_all_translations_keys(self):
        all_translations_keys = set()
        for translation_file in self.files:
            all_translations_keys.update(translation_file.content)

        print(" ")
        print_message("Todas as chaves de tradução foram carregadas...")
        print(" ")
        return all_translations_keys

    @abstractmethod
    def _get_translation_files(self) -> List[TranslationFile]:
        pass


class TranslationRepositoryBackend(TranslationRepository):
    def __init__(self):
        self.file_extension = ".properties"
        self.file_format = "PROPERTIES"
        self.translations_dir = Path("java/impl/src/main/resources/translation")
        super().__init__()

    def _get_translation_files(self) -> List[TranslationFile]:
        translation_files = []
        for file in self.translations_dir.iterdir():
            if file.suffix == self.file_extension:
                translation_files.append(TranslationFile(file, load_properties(file)))
        return translation_files


class TranslationRepositoryFrontend(TranslationRepository):
    def __init__(self):
        self.file_extension = ".json"
        self.file_format = "FLAT_JSON"
        self.translations_dir = Path("src/locale")
        super().__init__()

    def _get_translation_files(self) -> List[TranslationFile]:
        translation_files = []
        for file in self.translations_dir.iterdir():
            if file.suffix == self.file_extension:
                try:
                    data = json.loads(file.read_text())
                    translation_files.append(TranslationFile(file, data))
                except UnicodeError as err:
                    raise UnicodeError(
                        f"O arquivo contém caracteres não unicode, por favor substitua eles. Log do erro:\n{err}"
                    ) from err
        return translation_files
