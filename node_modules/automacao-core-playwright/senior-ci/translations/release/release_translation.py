from json import loads

import requests
from colorama import Fore

from common import (
    end_collapsible_section,
    exit_message,
    get_env_variable,
    get_env_variable_required,
    is_frontend,
    print_message,
    print_messages,
    start_collapsible_section,
)
from common.gitlab_helper import GitlabHelper
from translations.model import (
    TranslationRepositoryBackend,
    TranslationRepositoryFrontend,
)


class ReleaseTranslations(object):
    def __init__(self):
        self.gitlab_helper = GitlabHelper(get_env_variable("SCI_MANIFEST_PROJECT"))

        self.translation_repository = (
            TranslationRepositoryFrontend()
            if is_frontend()
            else TranslationRepositoryBackend()
        )

        repo_manifest_environment_host = (
            self.gitlab_helper.get_current_project_variable(
                "SCI_SENIORX_ENVIRONMENT_HOST",
                get_env_variable("SCI_SENIORX_ENVIRONMENT_HOST"),
            )
        )

        self.environment_host = (
            repo_manifest_environment_host
            if repo_manifest_environment_host
            else "cloud-leaf.senior.com.br"
        )
        self.base_url = (
            f"https://{self.environment_host}/t/senior.com.br/bridge/1.0/rest/platform"
        )
        self.session = requests.session()
        self._login()

    def exec(self):
        """Collect the translation files and import on the target environment"""

        section_id = start_collapsible_section(
            "Começando o processo de importação das traduções...", fore_color=Fore.CYAN
        )

        translation_hub_response = self._get(
            "translation_hub/queries/requestImportTranslations"
        )
        if not translation_hub_response.ok:
            exit_message("Não foi possível obter comunicação com o Translation Hub.")

        translation_hub_project = loads(translation_hub_response.content)

        imported_files = []

        for translation_file in self.translation_repository.files:
            if not translation_file.language:
                print_messages(
                    [
                        f"O arquivo de tradução {translation_file.path.name} não possui a linguagem definida, "
                        "logo será considerado como arquivo de fallback.",
                        "O arquivo de fallback não será importado.",
                    ],
                    Fore.YELLOW,
                )
                continue

            self._send_file_to_translation_hub(
                translation_hub_project["url"],
                translation_file.raw_content,
                translation_file.path.name,
            )
            lang_meta_json = {
                "id": translation_hub_project["id"],
                "language": translation_file.language,
                "format": self.translation_repository.file_format,
            }

            import_response = self._post(
                "translation_hub/signals/importDefaultTranslations", lang_meta_json
            )

            if import_response.ok:
                imported_files.append(translation_file.path.name)

        if not imported_files:
            exit_message(
                "Ocorreu um problema durante o processo de importação, "
                "nenhuma tradução foi importada."
            )

        print_messages(
            [
                "A requisição para importar as traduções foi realizada com sucesso!",
                f"Arquivos requisitados: {', '.join(imported_files)}.",
                f"Verifique os logs do Translation Hub para obter mais detalhes. ({self.environment_host})",
            ],
            fore_color=Fore.GREEN,
        )

        end_collapsible_section(section_id)

    def _send_file_to_translation_hub(
        self, url: str, translation_file: dict, filepath: str
    ):
        try:
            print_message(
                f"Enviando arquivo de tradução {filepath} para o Translation Hub..."
            )
            response = self._put(url, translation_file)
            if not response.ok:
                raise ValueError
        except Exception:
            print_message(
                f"Houve um erro no Translation Hub e não foi possível enviar o arquivo de tradução: Erro {response.status_code}",
                fore_color=Fore.YELLOW,
            )

    def _login(self):
        access_key = self.gitlab_helper.get_current_project_variable(
            "SCI_SENIORX_ACCESS_KEY",
            get_env_variable_required("SCI_LEAF_SENIORX_ACCESS_KEY"),
        )
        secret = self.gitlab_helper.get_current_project_variable(
            "SCI_SENIORX_SECRET",
            get_env_variable_required("SCI_LEAF_SENIORX_SECRET"),
        )
        if get_env_variable("PROD"):
            access_key = get_env_variable_required("SCI_SENIORX_ACCESS_KEY")
            secret = get_env_variable_required("SCI_SENIORX_SECRET")

        try:
            response = self._post(
                "authentication/actions/loginWithKey",
                {
                    "accessKey": access_key,
                    "secret": secret,
                    "tenantName": "senior",
                },
            )

            response_json = response.json()

            if response.status_code >= 400:
                raise SystemError(response_json["message"])

            json_token = loads(response_json["jsonToken"])
            self.session.headers = {
                "Authorization": f"Bearer {json_token['access_token']}"
            }
        except Exception as err:
            exit_message(
                f"Erro ao realizar login na Plataforma ({self.environment_host}): {err}"
            )

    @staticmethod
    def _put(url: str, data: dict):
        session_without_login = requests.session()
        return session_without_login.put(
            url=url,
            json=data,
            timeout=60.0,
        )

    def _post(self, url: str, data: dict):
        return self.session.post(
            url=f"{self.base_url}/{url}",
            json=data,
            timeout=60.0,
        )

    def _get(self, url: str):
        return self.session.get(url=f"{self.base_url}/{url}")
