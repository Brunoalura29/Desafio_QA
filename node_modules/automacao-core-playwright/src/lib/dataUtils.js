
const moment = require('moment');
const { expect } = require('@playwright/test');
const { addDays, isWeekend, format } = require('date-fns');
const dotenv = require('dotenv');
dotenv.config();

let contadorMenu = 0;
const FRAME = 'iframe[name="ci"]';

export class DataUtils {

  constructor(page) {
    this.page = page;
  }
  /**
  * Realiza o processo de login na página.
  * @param {Object} usuario - As informações de usuário para autenticação.
   * @example
   * const usuario = {
   *   email: 'seu_usuario@senior.com', {string}
   *   senha: 'sua_senha', {string}
   * };
  */
  async login(usuario) {
    await this.page.goto('/');

    const password = this.page.getByPlaceholder('Senha');
    const userName = this.page.getByPlaceholder('usuario@dominio.com.br');

    await userName.fill(usuario.email);

    await this.page.getByRole('button', { name: 'Próximo' }).click();

    await password.fill(usuario.senha);

    await this.page.locator('[id="loginbtn"]').click();
    console.log(`Usuário ${usuario.email} logado com sucesso`);
  }
  /**
 * Navega para a página da plataforma.
 * @param {string} produto - Produto a ser acessado.
 * @param {string|null} modulo - Módulo a ser acessado.
 * @param {string|null} area - Área a ser acessada.
 * @param {string|null} processo - Processo a ser acessado.
 * @param {string|null} subProcesso - Subprocesso a ser acessado.
 * @param {string|null} subProcesso2 - Segundo subprocesso a ser acessado.
 * @param {string|null} subProcesso3 - Terceiro subprocesso a ser acessado.
 */
  async navegarParaPagina(produto, modulo = null, area = null, processo = null, subProcesso = null, subProcesso2 = null, subProcesso3 = null) {
    const produtoXpath = `xpath=//div[contains(text(), "${produto}")]/ancestor::span[1]`;
    await this.page.waitForSelector(produtoXpath, { timeout: 60000 });
    await this.page.locator(produtoXpath).click({ force: true });

    const menuCount = await this.page.locator('#apps-menu-sublabel:has-text("Menu")').count();
    menuCount > 0 && (contadorMenu = 0);

    if (contadorMenu != 0) {
      do {
        const sublabelXpath = '[id="apps-menu-sublabel"]';
        await this.page.waitForSelector(sublabelXpath, { timeout: 60000 });
        await this.page.locator(sublabelXpath).click({ force: true });

        contadorMenu--;
      } while (contadorMenu > 1);
      contadorMenu = 0;
    }
    await this.navegarSeExistir(modulo);
    await this.navegarSeExistir(area);
    await this.navegarSeExistir(processo);
    await this.navegarSeExistir(subProcesso);
    await this.navegarSeExistir(subProcesso2);
    await this.navegarSeExistir(subProcesso3);
  }
  /**
   * Navega para um item do menu se ele existir.
   *
   * @param {string} itemMenu - O item para o qual navegar.
   * @returns {Promise} Uma promessa que se resolve quando a navegação é concluída.
   */
  async navegarSeExistir(itemMenu) {
    if (itemMenu) {
      const elementoMenuFiltrandoPeloFinalDaString = `a[aria-label$="${itemMenu}"]`;

      await this.page.locator(elementoMenuFiltrandoPeloFinalDaString).scrollIntoViewIfNeeded();
      await this.page.waitForSelector(elementoMenuFiltrandoPeloFinalDaString, { timeout: 60000 });
      await this.page.locator(elementoMenuFiltrandoPeloFinalDaString).click({ force: true });

      contadorMenu++;
    }
  }
  /**
   * Encontra um colaborador em uma tabela dentro de um iframe que
   * tem o seguinte locator: table.table tbody.
   *
   * @param {string} seletorTabela - Xpath ou locator referente a tabela desejada
   * @param {string} valorBusca - O valor a ser encontrado na tabela
   * @returns {Promise<ElementHandle>} Uma promessa que se resolve com a linha da tabela que contém o colaborador.
   * @throws {Error} Lança um erro se não conseguir localizar o colaborador na tabela.
   */
  async encontrarValorNaTabela(seletorTabela, valorBusca) {
    const frameElement = await this.page.$(FRAME);
    const frame = await frameElement.contentFrame();
    await frame.waitForSelector(seletorTabela, { timeout: 60000 });
    const linhas = await frame.locator(seletorTabela).elementHandles();
    for (let i = 0; i < linhas.length; i++) {
      // Obtenha o manipulador de elementos para a linha atual dentro do loop
      const linha = linhas[i];
      const celulas = await linha.$$('td');
      for (let j = 0; j < celulas.length; j++) {
        const valorCelula = await celulas[j].innerText();
        if (valorCelula === valorBusca) {
            return linha;
        }
      }
    }
    return null;
  }
  /**
   *  Função que verifica se um elemento está desabilitado na tela.
   * @param {string} componente informar qual é o elemento que deve ser validado na tela, locator
   * @param {string} desabilitado qual o valor esperado para ser comparado (true, false)
   */
  async verificaElementoDesabilitado(componente, desabilitado) {
    const frame = await this.page.frame({ name: 'ci' });
    const isDisabled = await frame.$eval(componente, el => el.hasAttribute('disabled'));
    //const isDisabled = await frame.$eval(componente, el => el.disabled);
    if (desabilitado) {
      expect(isDisabled).toBe(true);
      console.log('Botão ou campo desabilitado');
    } else {
      expect(isDisabled).toBe(false);
      console.log('Botão ou campo esta habilitado');
    }
  }
  async limparCampo(locator) {
    const frame = await this.page.frame({ name: 'ci' });
    await frame.locator(locator).click();
    await frame.locator(locator).press('Control+A');
    await frame.locator(locator).press('Backspace');
  }
  /**
 * Converte uma data no formato brasileiro para o formato americano (YYYY-MM-DD).
 * @param {string} data - Data no formato brasileiro (DD/MM/AAAA).
 * @returns {string} - Data no formato americano (YYYY-MM-DD).
 */
  formataDataAmericano(data) {
    return moment(data, 'DD/MM/YYYY').format('YYYY-MM-DD');
  }
  /**
 * Função que valida se a data informada é um feriado nacional, caso seja, retorna o dia seguinte ao feriado.
 * @param {string} dataInicioFerias - Data para validação (formato brasileiro de data - 22/04/2021)
 * @returns {string} - Data no formato "dia/mês/ano"
 */
  async validarFeriados(dataInicioFerias) {
    const dataValidarFeriadosEng = await this.formataDataAmericano(dataInicioFerias);
    const data = new Date(`"${dataValidarFeriadosEng}"`);
    const feriados = ['01/01', '21/04', '01/05', '02/09', '07/09', '12/10', '02/11', '15/11', '25/12'];

    let inicioFerias;
    let continuar = true;

    // Verifica a data de início das férias e os dois dias anteriores
    while (continuar) {
      continuar = false;
      for (let i = 0; i < 3; i++) {
        const novoDia = data.getDate() + i;
        const novoMes = data.getMonth() + 1;
        inicioFerias = this.configurarDiaMes(novoDia, novoMes);

        // Se a data for um feriado, ajusta a data de início das férias para o dia seguinte ao feriado
        if (feriados.includes(inicioFerias)) {
          data.setDate(data.getDate() + 3);
          continuar = true;
          break;
        }
      }
    }

    inicioFerias = this.configurarDiaMes(data.getDate(), data.getMonth() + 1);
    return `${inicioFerias}/${data.getFullYear()}`;
  }
  /** Função que valida se a data informada: é uma Sexta, Sábado ou Domingo, caso o retorno seja positivo,
  *  a data é forçada para a próxima Segunda.
  * @param {data} dataInicioFerias data para validação (em formato brasileiro de data - 22/04/2021)
  * REGRA DE NEGÓCIO G5: Não é permitido iniciar as férias no período de dois dias que antecedem um DSR.
      [0] - Domingo
      [1] - Segunda
      [2] - Terça
      [3] - Quarta
      [4] - Quinta
      [5] - Sexta
      [6] - Sábado
  * @returns {string} - Data ajustada, se necessário, para a próxima Segunda.
  **/
      async validarDiaUtilFerias(dataInicioFerias) {
        // Valida se a data informada é um feriado
        let dataValidarFeriados = await this.validarFeriados(dataInicioFerias);
        // Valida se a data é véspera de um feriado
        dataValidarFeriados = await this.page.feriasPage.validarVesperaFeriados(dataValidarFeriados);
        // Formata a data informada no padão americano
        const dataValidarFeriadosEng = await this.formataDataAmericano(dataValidarFeriados);
        let data = new Date(dataValidarFeriadosEng);
        // Se a data for uma sexta-feira, sábado ou domingo, ajusta a data para a próxima segunda-feira
        if (isWeekend(data) || data.getDay() === 5) {
          while (isWeekend(data) || data.getDay() !== 1) {
            data = addDays(data, 1);
          }
        }
        return format(data, 'dd/MM/yyyy');
      }
    /**
   * Configura o dia e o mês com zero à esquerda se o valor for menor que 10.
   * @param {number} dia - O dia a ser configurado.
   * @param {number} mes - O mês a ser configurado.
   * @param {boolean} [formatAmericano=false] - Se true, retorna no formato americano (mes/dia); caso contrário, retorna no formato brasileiro (dia/mes).
   * @returns {string} - Dia e mês formatados.
   */
    configurarDiaMes(dia, mes, formatAmericano = false) {
      const data = new Date(0, mes - 1, dia); // Ano 0 é usado aqui porque só estamos interessados no mês e no dia
      if (formatAmericano) {
        return format(data, 'MM/dd');
      } else {
        return format(data, 'dd/MM');
      }
    }
  /**
   * Valida se não há mensagens de erro na tela.
   *
   * Esta função verifica se determinadas mensagens de erro comuns não estão visíveis no frame especificado.
   *
   * @async
   * @function validaSemMsgErroEmTela
   * @returns {Promise<void>} Uma promessa que é resolvida quando todas as verificações são concluídas.
   */
  async validaSemMsgErroEmTela() {
    const frame = await this.page.frameLocator(FRAME);
    const errorMessages = [
      'Ocorreu um erro inesperado no servidor:',
      'Erro',
      'Oops',
      'Erro na busca das informações.',
      'expection',
    ];

    await Promise.all(
      errorMessages.map(async (errorMessage) => {
        await expect(frame.getByText(errorMessage, { exact: false })).toBeHidden();
      })
    );
  }
  /**
   * Valida a tradução de mensagens comuns na tela.
   *
   * Esta função verifica se as mensagens de tradução e os botões comuns estão ocultos no frame especificado.
   *
   * @async
   * @function validaTraducaoComunsEmTela
   * @returns {Promise<void>} Uma promessa que é resolvida quando todas as verificações são concluídas.
   */
  async validaTraducaoComunsEmTela() {
    const frame = this.page.frameLocator(FRAME);
    const translateMessages = ['erpx_', 'erp_'];
    const buttonsElements = ['add', 'edit', 'cancel', 'delete', 'save'];

    await Promise.all([
      ...translateMessages.map(async (translateMessage) => {
        await expect(frame.getByRole('body')).toBeHidden(translateMessage);
      }),
      ...buttonsElements.map(async (buttonsMessage) => {
        await expect(frame.getByRole('button', { name: buttonsMessage })).toBeHidden();
      })
    ]);
  }
}
